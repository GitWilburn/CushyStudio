// HIGH LEVEL THEME-DEFINED BOX STYLES
// everything is boxes,
// but lot of boxes have similar styles
// and lot of behaviours (beeing pressed, beeing active)
// need to slightly ajust those styles
// frame offer a semantic vocabulary to define look and feel of
// any surface at a higher level than the Box API.
// you can always specify BOX api directly if you need more control
// the frame will merge the low level api on top of the compiled style from
// the high level api

import type { BoxUIProps } from '../box/BoxUIProps'
import type { IconName } from '../icons/icons'
import type { Kolor } from '../kolor/Kolor'
import type { FrameSize } from './FrameSize'
import type { FrameAppearance } from './FrameTemplates'

import { forwardRef, useContext, useState } from 'react'

import { observer } from 'mobx-react-lite'

import { type BoxNormalized, normalizeBox } from '../box/BoxNormalized'
import { CurrentStyleCtx } from '../box/CurrentStyleCtx'
import { usePressLogic } from '../button/usePressLogic'
import { IkonOf } from '../icons/iconHelpers'
import { applyKolorToOKLCH } from '../kolor/applyRelative'
import { formatOKLCH } from '../kolor/formatOKLCH'
import { isSameOKLCH, type OKLCH } from '../kolor/OKLCH'
import { overrideKolor } from '../kolor/overrideKolor'
import { overrideKolorsV2 } from '../kolor/overrideKolorsV2'
import { compileOrRetrieveClassName } from '../tinyCSS/quickClass'

// import { hashKolor } from '../box/compileBoxClassName'
// import { compileKolorToCSSExpression } from '../kolor/compileKolorToCSSExpression'
// import { addRule, hasRule } from '../tinyCSS/compileOrRetrieveClassName'
import { frameTemplates } from './FrameTemplates'

export type FrameProps = {
    tooltip?: string
    // logic --------------------------------------------------
    /** TODO: */
    triggerOnPress?: { startingState: boolean }
    // STATES MODIFIERS ------------------------------------------------
    active?: Maybe<boolean>
    loading?: boolean
    disabled?: boolean

    // FITT size ----------------------------------------------------
    // /** when true flex=1 */
    expand?: boolean

    /** HIGH LEVEL THEME-DEFINED BOX STYLES */
    look?: FrameAppearance
    // ICON --------------------------------------------------
    icon?: Maybe<IconName>
    iconSize?: string

    suffixIcon?: Maybe<IconName>
} & BoxUIProps &
    /** Sizing and aspect ratio vocabulary */
    FrameSize

// ----------------------------------------------------------------------
// 2024-06-10 rvion:
// TODO:
//  ‚ùå we can't compile hover with the same name as non hover sadly;
//  üü¢ but we can add both classes directly
//  üü¢ we could also probably debounce class compilation
//  üü¢ and auto-clean classes
//  üü¢ and have some better caching mechanism so we don't have to normalize colors
//     nor do anything extra when the input does change

// ------------------------------------------------------------------
// quick and dirty way to configure frame to use either style or className
type FrameMode = 'CLASSNAME' | 'STYLE'
let frameMode: FrameMode = 1 - 1 === 1 ? 'STYLE' : 'CLASSNAME'
export const configureFrameEngine = (mode: FrameMode) => {
    frameMode = mode
}
// ------------------------------------------------------------------

export const Frame = observer(
    forwardRef(function Frame_(p: FrameProps, ref: any) {
        // PROPS --------------------------------------------
        // prettier-ignore
        const {
            active, disabled, // built-in state & style modifiers
            icon, iconSize, suffixIcon, loading, // addons
            expand, square, size, // size
            look, // templates
            base, hover, border, text, textShadow, shadow, // box stuff
            onMouseDown, onMouseEnter, onClick, triggerOnPress,
            style, className,
            tooltip,
            ...rest
        } = p

        // TEMPLATE -------------------------------------------
        const box = normalizeBox(p)
        const [hovered, setHovered] = useState(false)
        const prevCtx = useContext(CurrentStyleCtx)
        const variables: { [key: string]: string | number } = {}

        // retrieve template if specified
        const template:BoxNormalized | null = (look!=null)? frameTemplates[look]:null

        // let baseA = box.base // ?? prevCtx.base
        // nextBase =
        //  ctx.base
        //  |> apply look.base
        //  |> apply p.base
        //  |> apply disable (contrast: 0)
        //  |> apply p.hover if hovered
        let KBase: OKLCH = applyKolorToOKLCH(
            prevCtx.base,
            overrideKolorsV2(
                template?.base,
                box.base,
                disabled && {lightness: prevCtx.base.lightness},
                // hovered && !disabled && box.hover
            )
        )
        // if (template?.base) KBase = applyKolorToOKLCH(KBase, template.base)
        // if (box.base) KBase = applyKolorToOKLCH(KBase, box.base)
        // if (disabled) KBase.lightness = prevCtx.base.lightness

        if (hovered && !disabled && box.hover) {
            KBase = applyKolorToOKLCH(KBase, box.hover)
        }

        //  update ctx.base for children
        if (!isSameOKLCH(prevCtx.base, KBase)) {
            variables['--KLR'] = formatOKLCH(KBase)
        }
        // set the background to the KBase (apply shock if any)
        if (box.shock == null) {
            variables.background = formatOKLCH(KBase)
        } else {
            const KShock = applyKolorToOKLCH(KBase, box.shock)
            variables.background = formatOKLCH(KShock)
        }


        // text
        // ctx.text
        //  |> merge
        //  |> apply look
        //  |> apply whatever
        let KText: OKLCH = KBase
        const textRule = overrideKolorsV2(prevCtx.text, template?.text, box.text)!
        if (template?.text) KText = applyKolorToOKLCH(KText, template.text)
        // if (disabled) KText = applyKolorToOKLCH(KText, { contrast: 0.1 })
        // else
        KText = applyKolorToOKLCH(KText, textRule)
        variables.color = formatOKLCH(KText)
        // const boxText = textRule // box.text ?? prevCtx.text
        // CONTEXT ---------------------------------------------


        if (box.border || template?.border) {
            let KBorder = KBase
            const borderRule = overrideKolor(box.border, template?.border)
            KBorder = applyKolorToOKLCH(KBorder, borderRule)
            variables.border = `1px solid ${formatOKLCH(KBorder)}`
        }

        // next dir
        const nextLightness = KBase.lightness
        const _goingTooDark = prevCtx.dir === 1 && nextLightness > 0.7
        const _goingTooLight = prevCtx.dir === -1 && nextLightness < 0.45
        const nextDir = _goingTooDark ? -1 : _goingTooLight ? 1 : prevCtx.dir
        if (nextDir !== prevCtx.dir) variables['--DIR'] = nextDir.toString()

        // STYLE ---------------------------------------------
        // if (!isSameOKLCH(prevCtx.base, KBase)) variables['--KLR'] = formatOKLCH(KBase)
        // ‚è∏Ô∏è if (!isSameOKLCH(prevCtx.baseH, nextBaseH)) variables['--KLRH'] = formatOKLCH(nextBaseH)

        // CLASSES ---------------------------------------------
        // const classes: string[] = []


        if (box.textShadow) variables.textShadow = `0px 0px 2px ${formatOKLCH(applyKolorToOKLCH(KBase, box.textShadow))}`

        let _onMouseOver: any = undefined
        let _onMouseOut: any = undefined
        if (p.hover != null) {
            _onMouseOver = () => setHovered(true)
            _onMouseOut = () => setHovered(false)
        }

        return (
            <div //
                ref={ref}
                title={tooltip}
                onMouseOver={_onMouseOver}
                onMouseOut={_onMouseOut}
                tw={[
                    'box',
                    frameMode === 'CLASSNAME' ? compileOrRetrieveClassName(variables) : undefined,
                    size && `box-${size}`,
                    square && `box-square`,
                    loading && 'relative',
                    expand && 'flex-1',
                    // ...classes,
                    className,
                ]}
                style={frameMode === 'CLASSNAME' ? style : { ...style, ...variables }}
                {...rest}
                {...(triggerOnPress != null
                    ? usePressLogic({ onMouseDown, onMouseEnter, onClick }, triggerOnPress.startingState)
                    : { onMouseDown, onMouseEnter, onClick })}
            >
                <CurrentStyleCtx.Provider
                    value={{
                        dir: nextDir,
                        base: KBase,
                        // ‚è∏Ô∏è baseH: nextBaseH,
                        text: textRule,
                    }}
                >
                    {icon && <IkonOf tw='pointer-events-none flex-none' name={icon} size={iconSize} />}
                    {p.children}
                    {suffixIcon && <IkonOf tw='pointer-events-none' name={suffixIcon} size={iconSize} />}
                    {loading && <div tw='loading loading-spinner absolute loading-sm self-center justify-self-center' />}
                </CurrentStyleCtx.Provider>
            </div>
        )
    }),
)

// if (look != null) {
//     const template = frameTemplates[look]
//     if (template.base) baseA = overrideKolor(template.base, baseA)
//     if (template.border) box.border = overrideKolor(template.border, box.border)
//     if (template.text) box.text = overrideKolor(template.text, box.text)
// }

// let realBase = hovered ? box.hover ?? baseA : baseA

// MODIFIERS ---------------------------------------------
// 2024-06-05 I'm not quite sure having those modifiers here is a good idea
// I originally though they were standard; but they are probably not
// ‚è∏Ô∏è if (disabled) {
// ‚è∏Ô∏è     box.text = { contrast: 0.1 }
// ‚è∏Ô∏è     realBase = { contrast: 0 }
// ‚è∏Ô∏è     //     box.border = null
// ‚è∏Ô∏è }
// ‚è∏Ô∏è
// ‚è∏Ô∏è if (active) {
// ‚è∏Ô∏è     box.border = { contrast: 0.5 }
// ‚è∏Ô∏è     box.text = { contrast: 0.9 }
// ‚è∏Ô∏è }
